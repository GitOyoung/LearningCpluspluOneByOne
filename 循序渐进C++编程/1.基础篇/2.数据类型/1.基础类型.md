# 基础类型

## 整型
    1. 分为有符号( signed前缀)和无符号(unsinged前缀)两类，默认为有符号类型.有符号表示整数可以表达正负，而无符号只能表示非负整数
    2. 按字节大小排序： char < short <= int <= long <= long long，字节大小详情如下
    char / unsigned char : 1个字节， 8位
    short / unsigned short : 2个字节， 16位
    int / unsigned int: 与CPU的字长有关， 在单片机领域，早期的16位单片机int 都是2字节的，在32位CPU之后乃至64位CPU出现之后， int都是4字节的
    long / unsigned long: 标准规定long的字节数不小于int, 不大于long long, 跟编译器有关，在VC环境下， long和int一样， 在GCC环境下， long的字节数和long long一样， 都是8字节
    3. 整型数据的使用就像我们数学里面的整数一样，可以直接使用+ - ✖ ÷, 并且运算规则也与我们平常使用算式的规则一样， 先乘除后加减， 不过在C++中， 乘除使用的符号并不是数学中的乘除符号， 乘用*， 除用/, 其中的除也不是平常数学中的除， 而是整除，我们都知道两个整数相除规则是： 被除数 / 除数 = 商 + 余数， C++的整除就是只取商而忽略余数， 那么余数怎么获得呢？ C++有专门的去余数的操作符号， 叫取模, 用的符号也很常见， 就是%, 比如 10 % 3 结果是1， 9 % 5 结果是 4
    4. 既然整数有不同的字节数， 那不同字节数能表示的整数范围也不一样
        有符号整数范围是:         - 2 ^ (n - 1) 到 2 ^ (n - 1) -1
        无符号整数范围是:     0 到 2 ^ n - 1
        注: 上面的 ^ 符号表示次方运算， 2 ^ n 表示 2的n 次方， 其中n表示该类型的数据占用的位数，即字节数乘以8之后的结果
    5. 整数之间也有比较， 比较包括 < <= == != >= > 
        分别代表"小于"、"小于等于"、"等于"、"不等于"、"大于等于"、"大于"， 比如
        3 < 5,  8 != 9, 6 >= 2, 10 <= 100等等， 这些判断的结果叫布尔值， 只有两种结果，要么真(成立), 要么假(不成立)
    6. 通过以上我们知道整数是用若干位(8的倍数)的0和1组成，那我们是不是也有针对某些位进行的操作呢？
        答案当然是: 有的， 还不少呢
        我们都知道:
             0 与 任何值(0和1)都得0， 
             1 或任何值(0和1) 都得1，
             任意两个不一样的值相 异或 结果都得1
             1值取 非 得0 ， 0值取 非 得1
        那 上面所说的 与 或 异或 非 在C++都怎么实现呢？
        在C++里， 这些逻辑操作分为两类， 逻辑上的，和位操作
        A. 逻辑上的与 或 非(逻辑上一般没有异或)用的操作符号分别为 &&(与)、 ||(或)、!(非)
        在C++11之后增加了 and or not 等关键字来代表 与 或 非
        具体使用如下:
            a < b && b < c 表示 a小于b, 并且 b小于c
            a < 0 || a > 0 表示 a小于0 或者 a大于0 (其实就是a 不等于0， 数学中的区间表示为 (-∞，0) ∪ (0, +∞))
        B. 按位操作的与或非以及异或用的操作符分别是 &(位与) |(位或) ~(位取反) ^(异或)
        10001001 & 10000110 值为 1000000 
        10100011 | 00011111 值为 1011111
        ~10100101 值为 01011010
        10101010 ^ 11111111 = 01010101
        C. 位移操作， 分为左移和右移 代表符号 << >> 这两个符号在C++中也会有其他作用后续会介绍到
            00000001 << 4 值为 00010000 
            11110000 >> 4 值为 00001111

## 实数型(浮点型)
    1. 根据精度可以分为两种， 单精度浮点型 float和双精度浮点型 double, 高精度浮点型 long double
    2. 浮点型默认都是有符号的，有正负，也能像整数型一样做加减乘除运算， 但是没有位运算， 浮点数的位运算没有意义， 但是浮点数的除法不再是整除了， 而是真的数学意义上的除法，只是计算的结果如果有小数位的话，可能得不得精确值， 这是由于二进制表示的原因， 毕竟二进制能表示的值都是2 ^ n次方的组合值，不可能囊括数学意义上的所有实数， 举个例子来说， 浮点数可以精确表示0.25但是不能精确表示0.1，不信你可以自己试试打印一下
## 布尔型
    1.类型表示为bool, 就是用来表示布尔值(真或假)的类型， 值只有两个， true(真)， false(假)
    2. 所有的逻辑操作的结果都是布尔值，也就是布尔类型
    3. C++是兼容C的， 但是C语言里面是没有布尔类型的，都是用整形来代替， 所有的非0值都是真， 只有0才是假， 所以才C++中， 整形都是可以隐式转换为布尔型(bool)的， 转换规则就和C语言的规则一样， 所有的非0都转换为true, 只有0才转换为false (包括后面会介绍的空指针)
## 字符型
    1. 类型表示 char， 其实就是一种整型， 只是这种整型有专门的用途， 就是用来表示我们在电脑屏幕上能看得见的字符，每一个能看到和看不到的字符都是由一个或多个字符型来存储的，常用的数学符号 + - * / 以及所有能在键盘上单个按键能对应字符都只占用一个char空间， 而中文字符(汉子以及符号)都用多个char 来存储
    2. 字符类型的值， 所有单个char能存储可见的字符都可以用单引号''引用来表示， 如， 我们的英文字母 A, 表示为字符类型时，写成 'A', 这种写法只能表示单个char能存储的字符， 还有一些特殊字符, 需要用转义字符\来辅助表示， 如'\n'表示换行 '\t'表示一个制表符 '\\'表示一个\
    3. 字符与字符之间也可以进行加减乘除， 只是这样结果会隐式转换成int型， 而char 型与int型的加减操作结果仍旧是char 型， 表示的是从当前的字符往后或者往前数的那个字符
## 数组类型
    1. 表示连续存储的多个同类型数值
    2. 表示方法在普通类型的变量名后面使用中括号[]将1个常数接在后面， 例如: 
        表示 3个int组成的数组： int array[3];
        表示 10个char组成的数组: char chars[10];
    3. 数组名字代表的是存储这个数组的那块内存空间的首地址(就是后面我们会介绍到的指针， 数组是一种特殊指针)
    4. 我们可以使用以下几种方式来方位数组中的元素:
        使用[]: 我们知道定义数组的时候， 我们中括号里面的数字表示的是数组元素的总个数， 但是在定义好数组之后使用[]加数字下标的方式， 就表示访问数组对应编号的某个元素， 但是在C语言以及C++以及整个C系列的编程语言中, 编号都是从0开始的， 0表示第一位， 1表示第2位, ...以此类推， 如 int a[100];  a[0] = 0; a[99] = 99; 要注意， 我们在使用[]加下标的方式访问数组元素的时候， 下标不能超过总数-1， 就比如 int a[100]; 那么我们在使用的时候，a[n]中的n 最大值只能是 99, 超过了会有未知的隐患
        使用*(表示把数组当成指针来对待): 对的， * 不仅能表示乘法(双目运算), 也能表示引用取某个地址的值(单目运算)，如 int a[100]; *a 表示a[0], *(a + 1) 表示a[1]; 所以你能使用 *(1 + a)也能使用 1[a] ,虽然编译器允许， 但是一般不建议这么搞
## 字符串类型
    1. 一般字面上的字符串都用双引号扩起来表示， 表示的是连续存储的一系列以0字符结尾的字符char数组, 如 "ABCDEFG"， 就包含了字符'A', 'B', 'C','D','E','F','G', '\0'(值为0)
    2. 我们通常用char数组来保存一个字符串, 如 char name[] = "XiaoHong"; 然后我们就可以用name来表示这个"XiaoHong"的字符串了， 当然， 既然是数组， 那就肯定能修改里面的值， 比如我用 name[5] = 'a'; 那么name就变成 "XiaoHang"了
        我这里为什么不写[]里面的数字呢？ 有两个原因， 一是要告诉读者， C++数组是可以根据初始值来自动分配空间的，上面的name其实就是自动分配空间的， 就相当于 char name[9] = "XiaoHong"; 的效果一模一样。 
        咦？ 有人要问了，明明只有8个字符， 怎么数字是9 ？ 这就是我第二个要讲的了，使用双引号引起来的一系列字符， C++编译器会在分配空间时在结尾补上一个'\0'(值就是0， 不是'0', '0'表示的是0这个字符)来表示结束， 因为'\0'字符本身没有任何意义， 正好可以用来表示字符串结尾
        所以， 如果用户自己想要一个能存储n 个字符的字符数组时， 记得多分配一个'\0'的空间哦 *^_^*, 不然存不下去的
    3. 标准C语言库里面为我们提供了很多操作字符串的函数，后续我们会介绍到，C++兼容了C语言， 所以C++也能用， 而且C++也有自己更加强大的用来表示字符串的类型，使用起来会更加友好
## 常量
    1. 常量并不是某种类型， 而是在所有的类型上的一种访问权限限定符， 常量用const 来定义， 表示某个标识符不可修改， 修饰变量时表示变量不可修改， 如  const int a = 100; 那么a的值就固定死了， 只能是100, 不能再给a赋值了, 
    2. const 的位置可以放在类型前面， 也可以放在变量前面， 如 const int a;和int const a;表示的意义是一样的，后续的指针部分会有更复杂的const使用介绍
    3. const 不仅可以修饰变量，也可以修饰某一种函数(具体是哪一种， 后面会有介绍， 基础部分一般也用不上)




